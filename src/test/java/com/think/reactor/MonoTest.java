package com.think.reactor;

import org.junit.jupiter.api.Test;
import org.springframework.core.io.ClassPathResource;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

/**
 * Mono test
 *
 * @author veione
 * @version 1.0.0
 * @date 2023年06月16日 09:49:00
 */
public class MonoTest {

    /**
     * Mono接口的分类：
     * <p>
     * 1. 静态工厂方法
     * <p>
     * 2. 异常处理方法
     * <p>
     * 3. 线程方法
     * <p>
     * 4. 调测方法
     * <p>
     * 5. Operator方法
     * <p>
     * 6. subscribe方法
     */

    /**
     * Mono.from()的主要使用场景是将不同类型的数据源转换为Mono。
     * 例如，我们可以使用Mono.fromCallable()将Callable类型的数据源转换为Mono，
     * 使用Mono.fromFuture()将CompletableFuture类型的数据源转换为Mono，
     * 使用Mono.fromRunnable()将Runnable类型的数据源转换为Mono，
     * 使用Mono.fromSupplier()将Supplier类型的数据源转换为Mono。
     * 此外，我们还可以使用Mono.fromIterable()将Iterable类型的数据源转换为Mono，
     * 使用Mono.fromArray()将数组类型的数据源转换为Mono，
     * 使用Mono.fromStream()将Stream类型的数据源转换为Mono。
     * 这些转换方法使得我们可以轻松地将不同类型的数据源转换为Mono，
     * 并在响应式编程中进行处理和操作。
     */

    /**
     * Mono.from(Publisher<? extends T> source)
     * 该方法接收一个Publisher,并确保它将产出0或1个数据。并且在消费第一个`onNext`后被取消。
     */
    @Test
    public void testMonoFrom() {
        Mono.from(Flux.just("hello, mono"))
                .subscribe(this::consoleConsume);
    }

    /**
     * 创建一个新的Mono产出指定的元素
     */
    @Test
    public void testJust() {
        Mono.just("hello, mono")
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a Mono producing its value using the provided Callable. If the Callable resolves to null, the resulting Mono completes empty.
     * 创建一个Mono使用给定的Callable产出的结果，如果Callable返回的是null，生成的 Mono 完成为空。
     */
    @Test
    public void testFromCallable() {
        Mono.fromCallable(() -> "hello, mono from callable")
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a Mono that terminates with an error immediately after being subscribed to.
     * The Throwable is generated by a Supplier, invoked each time there is a subscription and allowing for lazy instantiation.
     * 创建一个在订阅后立即以错误终止的 Mono。Throwable 由 Supplier 生成，每次有订阅时调用并允许延迟实例化。
     */
    @Test
    public void testError() {
        Mono.error(RuntimeException::new)
                .subscribe(this::consoleConsume, e -> {
                    System.out.println("捕获了异常：" + e.getMessage());
                    e.printStackTrace();
                });

        Mono.error(new RuntimeException())
                .subscribe(this::consoleConsume, e -> {
                    System.out.println("捕获了异常：" + e.getMessage());
                    e.printStackTrace();
                });
    }

    /**
     * Create a Mono that completes without emitting any item.
     * 创建一个不产出任何数据立刻完成的Mono
     */
    @Test
    public void testEmpty() {
        Mono.empty()
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a Mono that completes empty once the provided Runnable has been executed.
     * 创建一个 Mono，提供的 Runnable 一旦被执行，它就立刻完成并且返回为空,这个和之前的Callable类似,不过Callable是有返回值的，这个没有返回值。
     */
    @Test
    public void testFromRunnable() {
        Mono.fromRunnable(() -> {
            System.out.println("hello,mono, runnable task is running.");
        }).subscribe(this::consoleConsume);
    }

    /**
     * Return a {@link Mono} that will never signal any data, error or completion signal, essentially running indefinitely
     * 返回一个永远不会发出任何数据、错误或完成信号的Mono，本质上是无限期运行的。
     * <p>
     * Mono.never()的主要使用场景是在需要创建一个不发射任何数据、也不产生任何错误或完成信号的空Mono时使用。
     * 它通常用于测试和调试，并且可以与其他操作符（如delayUntil）结合使用来模拟某些特定的行为或场景。
     * 此外，Mono.never()还可以用于创建一个永远不会完成的Mono，以便在需要时可以手动取消订阅。
     */
    @Test
    public void testNever() {
        Mono.never()
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a Mono provider that will supply a target Mono to subscribe to for each Subscriber downstream.
     * 创建一个 Mono 提供者，它将为下游的每个订阅者提供一个要订阅的目标 Mono。
     * <p>
     * Mono.defer()的主要使用场景是在需要动态地创建Mono时使用。它可以延迟Mono的创建直到订阅时刻，以便根据订阅者的需求动态生成Mono。通过使用Mono.defer()，
     * 我们可以避免在应用程序启动时预先创建Mono，从而提高应用程序的性能和资源利用率。
     * 此外，Mono.defer()还可以在需要时使用其他操作符（如retryWhen）来处理Mono的错误和完成信号，以便实现更复杂的行为。
     */
    @Test
    public void testDefer() {
        Mono.defer(() -> Mono.just("hello, mono, I'm defer from mono."))
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a new Mono that emits the specified item if non null otherwise only emits onComplete.
     * 创建一个新的Mono，如果指定的数据不为空，则发出该数据，否则只发出完成信号。
     * <p>
     * Mono.justOrEmpty() 的主要使用场景是在需要将一个可能为空的项转化为 Mono 时使用。它会检查传入的项是否非空，
     * 如果不为空则创建一个发射该项的 Mono，否则创建一个只发出 onComplete 信号的 Mono。这种方式可以避免在创建 Mono 时出现空指针异常，
     * 并且可以确保 Mono 只会发射非空的项，从而避免出现不必要的错误。
     * 常见的使用场景包括从数据库或网络中获取一个对象，该对象可能为空，需要将其转化为 Mono 进行后续处理。
     */
    @Test
    public void testJustOrEmpty() {
        // 内部的实现是，如果给定的数据为空则使用Mono.empty()否则使用的是Mono.just()
        Mono.justOrEmpty("hello")
                .subscribe(this::consoleConsume);

        Optional<Integer> optional = Optional.ofNullable(100);
        Mono.justOrEmpty(optional)
                .subscribe(this::consoleConsume);
    }

    /**
     * Creates a deferred emitter that can be used with callback-based APIs to signal at most one value, a complete or an error signal.
     * 创建一个延迟的发射器，可与基于回调的API一起使用，以发出至多一个值、完整的信号或错误信号。
     * <p>
     * Mono.create() 方法用于创建一个 Mono 对象，这个 Mono 对象可以发出一个信号，这个信号可以是一个值、一个错误、或者一个终止信号。
     * 可以根据具体的使用场景来定义要发出的信号类型和实现方式。
     * 一些使用场景可能需要手动进行异步操作，或者根据其它条件来判定信号的发出。
     * 例如，当需要操作一个耗时的异步任务时，可以使用 Mono.create() 方法创建一个 Mono 对象，然后在异步任务执行完成后，
     * 通过 MonoSink 的 success() 方法来发出值信号。而如果异步任务执行失败，则可以通过 MonoSink 的 error() 方法来发出错误信号。
     * 总之，Mono.create() 方法的使用场景比较灵活，可以根据实际需求来定义需要发出的信号类型，因此在响应式编程中经常被使用。
     * </p>
     */
    @Test
    public void testCreate() {
        Mono<String> mono = Mono.create(sink -> {
            // 创建一个 CompletableFuture 对象
            CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
                // 模拟一个耗时的异步任务
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return "hello";
            });

            // 注册异步任务完成时的回调函数
            future.whenComplete((result, error) -> {
                if (error != null) {
                    sink.error(error); // 发出错误信号
                } else {
                    sink.success(result); // 发出结果值信号
                }
            });
        });

        mono.subscribe(this::consoleConsume);

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
    }

    /**
     * Create a Mono provider that will supply a target Mono to subscribe to for each Subscriber downstream.
     * This operator behaves the same way as defer(Supplier),
     * but accepts a Function that will receive the current ContextView as an argument.
     * <p>
     * 创建一个Mono提供者，为每个下游订阅者提供要订阅的目标Mono。该操作符的行为与defer（供应商）相同，
     * 但接受一个函数作为参数，该函数将接收当前的ContextView作为参数。
     * </p>
     * <p>
     * Mono.deferContextual()方法的主要用途是在代码执行时动态地获取当前的`Context`并基于该`Context`生成要返回的`Mono`对象。
     * 这对于需要访问当前上下文的操作非常有用，例如在要访问当前用户信息或者配置信息时。
     * 通过使用此方法，您可以将当前上下文中的信息作为参数传递给下游处理器并生成要返回的`Mono`对象。
     * <p>
     * 例如，如果您使用Spring WebFlux framework 处理HTTP请求和响应，可以使用`Mono.deferContextual()`方法来访问当前请求的`Context`。
     * 您可以从中提取HTTP头和请求参数等信息，并将其传递给下游操作进行处理。这使得您可以动态地生成和修改要返回的Mono对象，
     * 并可在同一请求的不同操作之间共享上下文信息，以简化代码逻辑并提高性能。
     */
    @Test
    public void testDeferContextual() {
        // 和Mono.defer()类似,但是会多了一个上下文的参数对象，可以通过这个上下文对象获取一些参数然后传递给下游数据
        Mono.deferContextual(ctx -> {
                    return Mono.just("context view, " + ctx.size());
                })
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a Mono which delays an onNext signal by a given duration on a default Scheduler and completes.
     * If the demand cannot be produced in time, an onError will be signalled instead.
     * The delay is introduced through the parallel default Scheduler.
     * <p>
     * 创建一个Mono对象，它将在默认的可并行调度器上发出一个指定时间的延迟onNext信号，并在完成后结束。
     * 如果无法按时产生订阅请求，则将发出一个onError信号。这种延迟通过使用可并行调度器来实现。
     * <p>
     * `Mono.delay()` 是 Project Reactor 中的一种操作符，用于在指定的时间延迟后，发出一个元素。
     * `Mono.delay()` 可以用于实现以下场景：
     * <p>
     * 1. 需要在一定时间延迟后执行某个操作的场景。
     * 2. 需要在超时后进行某些操作的场景，例如超时后返回默认值或者抛出异常。
     * 3. 需要实现某些带有时间限制的操作的场景，例如某些场合下需要强制等待一段时间后再进行下一步操作。
     */
    @Test
    public void testDelay() {
        Mono.delay(Duration.ofSeconds(1))
                .subscribe(this::consoleConsume);
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
    }

    /**
     * Pick the first Mono to emit any signal (value, empty completion or error) and replay that signal,
     * effectively behaving like the fastest of these competing sources.
     * <p>
     * Mono.firstWithSignal() 是 Project Reactor 中的一种操作符，用于从多个 Mono 中获取第一个信号（信号可以是值、完成或错误），并快速返回该信号。
     * 与 Mono.first() 不同的是，Mono.firstWithSignal() 可以捕获 Mono 中发生的所有信号，而不仅仅是第一个值信号。
     * Mono.firstWithSignal() 可以用于实现以下场景：
     * 需要从多个 Mono 中获取第一个信号并尽快返回。
     * 需要捕获所有 Mono 内部发生的信号的场景，例如在需要同时处理多个 Mono 的情况下，可以使用该操作符捕获全部 Mono 的信号，以便根据情况进行处理。
     */
    @Test
    public void testFirstWithSignal() {
        //简单就是快速成功或者快速失败
        Mono<String> mono1 = Mono.just("foo").delayElement(Duration.ofSeconds(1));
        Mono<String> mono2 = Mono.just("bar").delayElement(Duration.ofSeconds(2));
        Mono<String> mono3 = Mono.just("baz");

        Mono.firstWithSignal(mono1, mono2, mono3)
                .subscribe(this::consoleConsume);
    }

    /**
     * Mono.firstWithValue() 方法的使用场景是当您希望从一个 Mono 序列中获取一个非空值，并在第一个非空值被发现时立即终止序列时。
     * 如果在序列中找不到非空值，则Mono.firstWithValue() 方法将返回一个 Mono，它表示一个 NoSuchElementException。
     */
    @Test
    public void testFirstWithValue() {
        Mono<String> mono1 = Mono.empty();
        Mono<String> mono2 = Mono.just("hello");
        Mono<String> mono3 = Mono.just("world");

        Mono.firstWithValue(mono1, mono2, mono3)
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a Mono, producing its value using the provided CompletionStage.
     * 创建一个Mono，使用提供的CompletionStage生成其值。
     * <p>
     * 这意味着我们可以使用Mono.fromCompletionStage()方法，将一个CompletionStage对象转换成一个Mono对象。
     * Mono的值将会被异步地从CompletionStage对象中获取，并在CompletionStage对象完成时被触发。
     * <p>
     * 值得注意的是，Mono.fromCompletionStage()方法返回的Mono对象是一个hot的Mono，
     * 这意味着任何时刻都有可能会有新的事件（即值）进来。因此，在订阅这个Mono对象之前，
     * 这个CompletionStage对象可能已经完成，这种情况下，我们可能会错过它的值。
     * 因此，在使用Mono.fromCompletionStage()方法时，最好确保订阅时CompletionStage对象尚未完成。
     */
    @Test
    public void testFromCompletionStage() {
        CompletionStage<String> completionStage =
                CompletableFuture.supplyAsync(() -> "hello, world!");
        Mono.fromCompletionStage(completionStage)
                .subscribe(this::consoleConsume);
    }

    /**
     * Mono.fromDirect()是在响应式编程中使用的方法，它的主要作用是创建一个“直接”应发布到Mono（单个元素信号源）的对象。该方法旨在提高应用程序的性能和响应速度。
     * 使用Mono.fromDirect()的一个常见场景是在处理已经存在或可以同步生成的数据时，可以将其转换为Mono信号源发布，以便在订阅者实际订阅之前或同时立即发布该数据。
     * 这种方法比使用Mono.just()或Mono.defer()更加高效，因为它避免了创建额外的缓存对象和线程切换，从而提高了应用程序的性能和响应速度。
     * 另外，Mono.fromDirect()也可以与一些已经存在的异步API结合使用，以将其转换为与Reactive Streams兼容的信号源，从而更好地集成到已有的响应式编程框架中。
     */
    @Test
    public void testFromDirect() {
        Mono<String> mono = Mono.just("hello,world");
        Mono.fromDirect(mono)
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a Mono, producing its value using the provided CompletableFuture and cancelling the future if the Mono gets cancelled.
     * <p>
     * 创建一个Mono（单元素信号源），使用提供的CompletableFuture生成其值，并在Mono被取消时取消该future。
     * <p>
     * <p>
     * Mono.fromFuture()是响应式编程中使用的方法，它的主要作用是将一个Java Future对象转换为一个Mono信号源，以便在订阅Mono时发布产生的Future结果，并且可以通过该Mono对象进行流式处理和操作。
     * <p>
     * 使用Mono.fromFuture()的一个常见场景是，当使用异步操作（例如由CompletableFuture返回的异步结果）时，您希望在等待结果时能够让线程继续执行其他任务，而不必阻塞当前线程。这是因为Mono.fromFuture()中的Future对象可以在后台线程中异步地执行，
     * 直到结果就绪后再返回值给订阅者，因此可以提高应用程序的性能和响应速度。
     * <p>
     * 另外，使用Mono.fromFuture()还可以快速将一个现有的Future对象与可观察流或异步操作序列中的其他操作组合，以便更好地进行响应式编程。
     * 例如，在使用Spring框架实现响应式REST API时，可以通过Mono.fromFuture()将异步接口的结果转换为与Reactive Streams兼容的信号源，
     * 从而更好地使用基于流的Java API进行操作。
     */
    @Test
    public void testFromFuture() {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "hello,world");
        Mono.fromFuture(future)
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a Mono, producing its value using the provided Supplier. If the Supplier resolves to null,
     * the resulting Mono completes empty.
     * 创建一个Mono，使用提供的Supplier生成它的值。如果Supplier解析为null，那么生成的Mono会完成为空。
     * <p>
     * <p>
     * Mono.fromSupplier()方法可以用于创建一个Mono，该Mono可用于通过提供一个Supplier来生成其值。它的使用场景包括：
     * <p>
     * 异步获取数据：可以将异步获取数据的操作封装在Supplier中，并将其传递给fromSupplier()方法，从而创建一个用于获取数据的Mono。
     * <p>
     * 基于回调的操作：从Supplier返回的值可以是触发某些回调操作的参数，例如要去执行某些计算或者发送网络请求等。通过创建一个基于Supplier的Mono，
     * 可以将这些回调操作绑定到Mono上。
     * <p>
     * 延迟执行：在有些情况下，不想立即执行某个操作，而是想在某个时间点后再执行。在这种情况下，可以将要执行的操作封装在Supplier中，
     * 并将其传递给fromSupplier()方法，从而创建一个在需要的时候执行的Mono。
     * <p>
     * 总之，Mono.fromSupplier()方法可以用于生成需要通过某些操作异步获取的值的Mono，从而使得代码具有响应式编程的特性，提高代码的可读性和可维护性。
     */
    @Test
    public void testFromSupplier() {
        Mono.fromSupplier(() -> "hello, world")
                .subscribe(this::consoleConsume);
    }

    /**
     * Create a new Mono that ignores elements from the source (dropping them), but completes when the source completes.
     * 创建一个新的Mono，它忽略来自源流的元素（将它们丢弃），但在源流完成时完成。
     * <p>
     * Mono.ignoreElements()方法用于创建一个新的Mono，它会忽略来自源流的所有元素，只关注源流的完成事件。该方法的使用场景包括：
     * <p>
     * 1. 只关注源流完成事件：对于一些只需要知道某个操作是否完成，而不关注具体结果的场景，可以使用该方法创建一个忽略元素的Mono。
     * 2. 忽略不需要的元素：如果源流中包含一些不需要用到的元素，而又不想对这些元素进行处理，可以使用该方法创建一个忽略元素的Mono。
     * 3. 等待操作完成：当需要等待某个操作完成，但不需要处理操作结果时，例如等待异步任务完成，可以使用该方法创建一个等待操作完成的Mono。
     * <p>
     * 总之，Mono.ignoreElements()方法适用于一些只需要关注操作完成事件，而不关注具体结果的场景。
     */
    @Test
    public void testIgnoreElements() {
        Mono.ignoreElements(Flux.just("Hello, World!"))
                .subscribe(this::consoleConsume, null, () -> System.out.println("Mono completed!"));
    }

    /**
     * Returns a Mono that emits a Boolean value that indicates whether two Publisher sequences are the same by comparing the items emitted by each Publisher pairwise.
     * <p>
     * 返回一个Mono，该Mono会发出一个布尔值，该值指示通过逐个比较每个Publisher发出的项目，两个Publisher序列是否相同。
     * <p>
     * Mono.sequenceEqual() 方法用于判断两个 Mono 序列是否相等。它比较两个 Mono 序列发出的所有元素是否相等，以及它们完成的时间顺序是否相同。
     * <p>
     * 这个描述并不是 Mono.sequenceEqual() 的定义，可能是和另一个方法使用场景的描述混淆了。不过我可以分别解释一下这两段话的含义：
     * <p>
     * 1. Mono.sequenceEqual() 的使用场景是当我们有两个 Publisher 序列时，想要比较它们是否完全相同，即它们所发出的元素序列一一相等。
     * 这个方法会返回一个 Mono，它会发出一个布尔值，表示这两个序列是否相等。
     * <p>
     * 2. 使用 supplier 为每个 Subscriber 生成资源，同时从这个资源生成的 Mono 流中获取数据，并确保在序列结束或 Subscriber 取消订阅时释放资源。
     * 这是一个常见的处理资源获取和释放的模式，例如在使用文件或数据库连接等场景中，我们可以使用这个模式避免资源泄漏。
     */
    @Test
    public void testSequenceEqual() {
        Mono<Integer> mono1 = Mono.just(1);
        Mono<Integer> mono2 = Mono.just(2);
        Mono<Integer> mono3 = Mono.just(3);

        Mono.sequenceEqual(mono1, mono2)//false
                .subscribe(this::consoleConsume);

        Mono.sequenceEqual(mono1, mono1)//true
                .subscribe(this::consoleConsume);

        Mono.sequenceEqual(mono1, mono1.delayElement(Duration.ofMillis(100)))//true
                .subscribe(this::consoleConsume);

        Mono.sequenceEqual(mono1, Mono.zip(mono3, mono2, mono1).map(tuple -> tuple.getT3()))//true
                .subscribe(this::consoleConsume);

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
    }

    /**
     * Uses a resource, generated by a supplier for each individual Subscriber, while streaming the value from a
     * Mono derived from the same resource and makes sure the resource is released if the
     * sequence terminates or the Subscriber cancels.
     * <p>
     * 其使用给定的Supplier为每个独立订阅者生成资源，在从该资源派生的Mono上进行流式传输来获取价值，并确保在序列终止或订阅者取消时释放该资源。
     * <p>
     * <p>
     * Mono.using()是一个Java Reactor库的方法，用于创建一个Mono对象，在执行完成后自动关闭所需的资源。
     * 这个方法通常与需要管理资源（如文件、数据库连接等）的操作一起使用。
     * <p>
     * 具体来说，Mono.using()方法需要三个参数：资源创建函数、资源关闭函数和操作函数。在执行期间，using()方法将使用资源创建函数创建资源，
     * 执行操作并返回Mono对象，然后使用资源关闭函数来关闭资源。
     */
    @Test
    public void testUsing() {
        Mono.using(() -> Files.newBufferedReader(Path.of(new ClassPathResource("text.txt").getFile().getAbsolutePath())),
                        br -> {
                            try {
                                return Mono.just(br.readLine());
                            } catch (IOException e) {
                                return Mono.error(e);
                            }
                        },
                        br -> {
                            try {
                                br.close();
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        })
                .subscribe(this::consoleConsume);
    }

    /**
     * `Mono.usingWhen()` 方法在响应式编程中用于管理资源的创建和释放，它可以接收一个或多个 `Mono` 的实例。该方法会返回一个 `Mono` 它的行为取决于被传入的 `Mono` ，并且会在生命周期结束时自动释放资源。
     * <p>
     * 使用场景包括但不限于以下情况：
     * <p>
     * 1. 处理需要建立和释放资源的数据库事务。在该场景下，`Mono.usingWhen()` 用于封装事务处理，当任务结束时自动释放资源，可以避免发生泄漏。
     * 2. 处理需要建立和释放资源的 I/O 操作。在该场景下，`Mono.usingWhen()` 可以封装 I/O 操作和资源管理，确保资源被即时释放从而避免性能问题。
     * 3. 处理需要建立和释放资源的远程调用。在该场景下，`Mono.usingWhen()` 用于封装远程调用和资源管理，以确保外部资源被及时释放。
     * 总之，`Mono.usingWhen()` 方法的适用场景是需要管理资源的异步任务。
     */
    @Test
    public void testUsingWhen() throws Exception {
//        Path filePath = Path.of(new ClassPathResource("text.txt").getFile().getAbsolutePath());
//        Mono.usingWhen(() -> Files.newBufferedReader(filePath),
//                        (inputStream) -> Mono.fromCallable(() -> {
//                            byte[] bytes = inputStream.readAllBytes();
//                            return new String(bytes, StandardCharsets.UTF_8);
//                        }),
//                        this::closeInputStream)
//                .subscribe(this::consoleConsume);
    }

    /**
     * 将给定的发布者（publishers）聚合成一个新的 Mono。当所有给定的源（sources）完成时，此 Mono 将被满足。如果出现错误，将取消待处理结果并立即将错误发出到返回的 Mono。
     *
     * <p>
     * Mono.when() 用于将多个 Mono 组合成一个新的 Mono，称为“合并 Mono”，如果每个 Mono 完成时间不同，则会等待所有 Mono 完成后，
     * 将所有 Mono 的结果组合到一个新的 Mono 中。
     * <p>
     * 常见的使用场景是需要对多个异步操作返回结果进行合并，比如同时向多个服务发起请求，等待它们都返回结果后再进行后续的处理。
     */
    @Test
    public void testWhen() throws InterruptedException {
        Mono<String> firstDataSource = Mono.just("data from first data source")
                .delayElement(Duration.ofSeconds(1));
        Mono<String> secondDataSource = Mono.just("data from second data source")
                .delayElement(Duration.ofSeconds(2));

        firstDataSource.subscribe(System.out::println);
        secondDataSource.subscribe(System.out::println);

        Mono<Void> mono = Mono.when(firstDataSource, secondDataSource);
        mono.subscribe(System.out::println);


        Thread.sleep(5000);
    }

    /**
     * 将给定的发布者合并成一个新的Mono，仅当所有给定的源都完成时才会执行。来自源的错误被延迟处理。如果多个发布者出现错误，
     * 则将异常组合在一起（作为根异常上的抑制异常）。
     *
     * <p>
     * `Mono.whenDelayError()`方法是一个用于将多个`Mono`合并成一个`Mono`的操作符，它的主要作用是将多个`Mono`中的错误推迟到所有`Mono`完成之后再一起抛出。该操作符在以下场景中可能会被使用到：
     * <p>
     * 1. 当需要将多个`Mono`结果合并成一个`Mono`并且希望在最后才抛出所有的错误时，使用`Mono.whenDelayError()`可以避免因为中途抛出错误导致整个合并操作被中断。
     * 2. 当合并多个`Mono`时，如果其中有一个`Mono`发生了错误，使用`Mono.whenDelayError()`可以确保其他`Mono`继续运行并完成结果的合并。
     * 3. 当多个`Mono`都有可能会抛出错误，但在错误发生时需要等待所有`Mono`完成后再一起抛出，使用`Mono.whenDelayError()`可以方便地处理错误，使代码更加简洁易读。
     * <p>
     * 需要注意的是，在使用`Mono.whenDelayError()`时，用户需要手动处理所有可能会产生的错误，否则可能会导致未处理的错误被隐蔽或丢失。
     * </p>
     */
    @Test
    public void testWhenDelayError() {
        Mono.whenDelayError(Mono.empty(), Flux.empty())
                .block();
    }

    /**
     * Merge given monos into a new Mono that will be fulfilled when all of the given Monos have produced an item,
     * aggregating their values into a Tuple3. An error or empty completion of any source will cause other sources
     * to be cancelled and the resulting Mono to immediately error or complete, respectively.
     *
     * 将给定的 Mono 合并成一个新的 Mono，当所有给定的 Mono 都产生了一个项目时，将它们的值合并成一个 Tuple3。
     * 任何一个源的错误或空完成都会导致其他源被取消，结果 Mono 会立即报错或完成。
     *
     * `Mono.zip()` 函数用于将多个 Mono 序列合并成一个新的 Mono 序列，这个新的序列中的元素是一个元组，包含了每个输入序列中的对应元素。
     * 例如，如果你有两个 Mono 序列，一个是返回字符串的 Mono，一个是返回整数的 Mono，你可以使用 `Mono.zip()` 来将它们合并成一个新的 Mono，
     * 输出的元素是一个包含字符串和整数的元组。
     *
     * 举个例子，比如你想同时请求两个不同的网络端点，一个返回用户信息，一个返回用户所在城市的信息，
     * 你可以使用 `Mono.zip()` 函数将它们合并成一个 Mono，这样你就可以得到一个包含了用户信息和城市信息的元组，
     * 然后你可以对这个元组进行处理或者转换成其他的类型。
     */
    @Test
    public void testZip() {
        Mono<String> mono1 = Mono.just("foo");
        Mono<String> mono2 = Mono.just("bar");
        Mono<String> mono3 = Mono.just("tar");

        Mono.zip(mono1, mono2, mono3)
                .subscribe(this::consoleConsume);

    }

    /**
     * `Mono.zipDelayError()` 方法是 Reactor Core 提供的一个方法，用于将多个 Mono 序列合并为一个元素序列，
     * 并发出它们的最新元素，如果其中一个 Mono 序列发生错误，则会将错误推迟到其他 Mono 序列发出元素之后，
     * 最终将所有错误收集到一个 CompositeException 中并抛出。
     *
     * 常见的使用场景包括：当我们需要等到多个 Mono 返回结果之后再进行操作，或者需要并发请求多个远程服务并将它们的返回结果合并为一个结果。
     * 同时，由于这个方法会将错误推迟到其他 Mono 发出元素之后再抛出，因此可以用于容错处理，确保即使其中一个 Mono 抛出异常，
     * 其他 Mono 的结果仍然能够被正常处理。
     */
    @Test
    public void testZipDelayError() {
        Mono<String> mono1 = Mono.just("foo");
        Mono<String> mono2 = Mono.just("bar");
        Mono<String> mono3 = Mono.error(RuntimeException::new);

        Mono.zipDelayError(mono1, mono2, mono3)
                .subscribe(this::consoleConsume);
    }

    public <T> void consoleConsume(T value) {
        System.out.println(value);
    }

}
